import * as fs from "node:fs";
import * as path from "node:path";

export interface IsolatedSession {
  sessionId: string;
  basePath: string;
  providerPath: string;
  provider: "zai" | "minimax";
  claudeDir: string;
}

export function createIsolatedSession(
  provider: "zai" | "minimax",
  sessionId?: string
): IsolatedSession {
  const id =
    sessionId ||
    `compare_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
  const basePath = `/tmp/imbios-compare/${id}`;
  const providerPath = path.join(basePath, provider);
  const claudeDir = path.join(providerPath, ".claude");

  // Create directory structure
  fs.mkdirSync(claudeDir, { recursive: true });

  return {
    sessionId: id,
    basePath,
    providerPath,
    provider,
    claudeDir,
  };
}

export function generateClaudeMd(
  provider: "zai" | "minimax",
  customInstructions?: string
): string {
  const providerInstructions = {
    zai: `# Z.AI Provider Instructions

You are using the Z.AI (GLM) provider. Your API base URL is configured to use GLM models.

Available models:
- GLM-4.7 (default)
- GLM-4.5-Air

When writing code, prefer TypeScript and follow these patterns:
- Use modern async/await syntax
- Use arrow functions for callbacks
- Prefer const over let
- Use optional chaining (?.) and nullish coalescing (??)

For MCP tools, use the Z.AI-specific servers when available.
`,
    minimax: `# MiniMax Provider Instructions

You are using the MiniMax provider. Your API base URL is configured to use MiniMax models.

Available models:
- MiniMax-M2.1 (default)

When writing code, prefer TypeScript and follow these patterns:
- Use modern async/await syntax
- Use arrow functions for callbacks
- Prefer const over let
- Use optional chaining (?.) and nullish coalescing (??)

For MCP tools, use the MiniMax-specific servers when available.
`,
  };

  let content = providerInstructions[provider];

  if (customInstructions) {
    content += `\n## Custom Instructions\n\n${customInstructions}`;
  }

  return content;
}

export function generateEnvFile(
  apiKey: string,
  baseUrl: string,
  defaultModel: string
): string {
  return `# Generated by ImBIOS Compare
# Provider: ${baseUrl.includes("z.ai") ? "Z.AI" : "MiniMax"}
ANTHROPIC_AUTH_TOKEN="${apiKey}"
ANTHROPIC_BASE_URL="${baseUrl}"
ANTHROPIC_MODEL="${defaultModel}"
API_TIMEOUT_MS=3000000
`;
}

export function setupSessionFiles(
  session: IsolatedSession,
  apiKey: string,
  baseUrl: string,
  defaultModel: string,
  customInstructions?: string
): void {
  // Write CLAUDE.md
  const claudeMdPath = path.join(session.claudeDir, "CLAUDE.md");
  fs.writeFileSync(
    claudeMdPath,
    generateClaudeMd(session.provider, customInstructions)
  );

  // Write .env file
  const envPath = path.join(session.claudeDir, ".env");
  fs.writeFileSync(envPath, generateEnvFile(apiKey, baseUrl, defaultModel));

  // Write settings.json
  const settingsPath = path.join(session.claudeDir, "settings.json");
  fs.writeFileSync(
    settingsPath,
    JSON.stringify(
      {
        version: "1.0.0",
        provider: session.provider,
        baseUrl,
        defaultModel,
        mcpServers: {},
      },
      null,
      2
    )
  );
}

export function symlinkProjectFiles(
  projectPath: string,
  sessionPath: string
): void {
  if (!fs.existsSync(projectPath)) {
    return;
  }

  const entries = fs.readdirSync(projectPath, { withFileTypes: true });

  for (const entry of entries) {
    const srcPath = path.join(projectPath, entry.name);
    const destPath = path.join(sessionPath, entry.name);

    // Skip .claude directory in source
    if (entry.name === ".claude" && entry.isDirectory()) {
      continue;
    }

    // Skip node_modules and other large directories
    if (
      entry.name === "node_modules" ||
      entry.name === ".git" ||
      entry.name === "dist" ||
      entry.name === "build"
    ) {
      continue;
    }

    try {
      if (entry.isSymbolicLink()) {
        fs.unlinkSync(destPath);
      } else if (entry.isDirectory()) {
        fs.mkdirSync(destPath, { recursive: true });
        symlinkProjectFiles(srcPath, destPath);
      } else if (entry.isFile()) {
        fs.symlinkSync(srcPath, destPath);
      }
    } catch {
      // Ignore errors
    }
  }
}

export function cleanupSession(session: IsolatedSession): void {
  try {
    fs.rmSync(session.basePath, { recursive: true, force: true });
  } catch {
    // Ignore cleanup errors
  }
}

export function getCompareHistoryPath(): string {
  const configDir = `${process.env.HOME || process.env.USERPROFILE}/.claude`;
  return path.join(configDir, "imbios-compare", "history.json");
}

export interface CompareSessionRecord {
  id: string;
  timestamp: string;
  prompt: string;
  zaiResult?: ClaudeResult;
  minimaxResult?: ClaudeResult;
  winner?: "zai" | "minimax" | "tie";
}

export function saveCompareSession(record: CompareSessionRecord): void {
  const historyPath = getCompareHistoryPath();
  const historyDir = path.dirname(historyPath);

  fs.mkdirSync(historyDir, { recursive: true });

  let history: CompareSessionRecord[] = [];

  try {
    if (fs.existsSync(historyPath)) {
      history = JSON.parse(fs.readFileSync(historyPath, "utf-8"));
    }
  } catch {
    // Start fresh if file is corrupted
  }

  history.unshift(record);

  // Keep last 100 sessions
  if (history.length > 100) {
    history = history.slice(0, 100);
  }

  fs.writeFileSync(historyPath, JSON.stringify(history, null, 2));
}

export function loadCompareHistory(): CompareSessionRecord[] {
  const historyPath = getCompareHistoryPath();

  try {
    if (fs.existsSync(historyPath)) {
      return JSON.parse(fs.readFileSync(historyPath, "utf-8"));
    }
  } catch {
    // Ignore errors
  }

  return [];
}

export function getCompareSession(
  id: string
): CompareSessionRecord | undefined {
  const history = loadCompareHistory();
  return history.find((s) => s.id === id);
}

export interface ClaudeResult {
  provider: "zai" | "minimax";
  output: string;
  tokens?: number;
  timeMs: number;
  cost?: number;
  error?: string;
}
