#!/bin/sh
# Exit on any error
set -e

# Check if there are any staged files
if [ -z "$(git diff --cached --name-only)" ]; then
  echo "No staged files to format"
  exit 0
fi

# Store the hash of staged changes to detect modifications
STAGED_HASH=$(git diff --cached | sha256sum | cut -d' ' -f1)

# Save list of staged files (handling all file states)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR)
PARTIALLY_STAGED=$(git diff --name-only)

# Stash unstaged changes to preserve working directory
# --keep-index keeps staged changes in working tree
git stash push --quiet --keep-index --message "pre-commit-stash" || true
STASHED=$?

# Get list of staged files for Claude analysis
STAGED_LIST=$(git diff --cached --name-only --diff-filter=ACMR | tr '\n' ' ')

# Run security and performance analysis with Claude
echo "ðŸ” Running Claude Code security & performance analysis..."
if command -v claude >/dev/null 2>&1; then
  # Create a temporary file for the analysis
  ANALYSIS_OUTPUT=$(mktemp)

  # Run Claude analysis with structured output
  # Using --headless mode with structured output (json format)
  cat <<EOF | claude --headless --output-format json \
    --json-schema '{"type":"object","properties":{"blocking_issues":{"type":"array","items":{"type":"object","properties":{"file":{"type":"string"},"line":{"type":"number"},"severity":{"type":"string","enum":["critical","high","medium","low"]},"type":{"type":"string","enum":["security","performance","quality"]},"message":{"type":"string"}},"required":["file","severity","type","message"]}}}},"required":["blocking_issues"]}' \
    --allowed-tools "Read" \
    2>&1 | tee "$ANALYSIS_OUTPUT" || true

You can create an agent team, use subagents, do it in parallel, or do it yourself. Review these staged files: $STAGED_LIST

Check for:
1. Security vulnerabilities (SQL injection, XSS, auth issues, command injection, path traversal)
2. Performance issues (inefficient algorithms, missing indexes, N+1 queries, memory leaks)
3. Code quality (unused imports, missing error handling, type safety)

Return only the blocking issues in the structured output format.
EOF

  # Extract structured output and check for critical issues
  CRITICAL_ISSUES=$(cat "$ANALYSIS_OUTPUT" | jq -r '.structured_output.blocking_issues[]? | select(.severity == "critical")' 2>/dev/null || echo "")
  HIGH_ISSUES=$(cat "$ANALYSIS_OUTPUT" | jq -r '.structured_output.blocking_issues[]? | select(.severity == "high")' 2>/dev/null || echo "")

  # Check for critical blocking issues
  if [ -n "$CRITICAL_ISSUES" ]; then
    echo "âŒ CRITICAL SECURITY ISSUES FOUND - Commit blocked"
    echo "$CRITICAL_ISSUES" | jq -r '"\(.file):\(.line) - \(.message)"'
    echo "Review the analysis above and fix critical issues before committing."
    rm -f "$ANALYSIS_OUTPUT"
    exit 1
  fi

  # If high severity security issues, warn but allow bypass
  if [ -n "$HIGH_ISSUES" ]; then
    echo "âš ï¸  High severity issues found. Consider fixing before committing."
    echo "$HIGH_ISSUES" | jq -r '"\(.file):\(.line) - \(.message)"'
    echo "Press Enter to continue or Ctrl+C to abort..."
    read -r
  fi

  rm -f "$ANALYSIS_OUTPUT"
fi

# Run type checking
echo "ðŸ”Ž Running type check..."
bun run typecheck

# Run tests
echo "ðŸ§ª Running tests..."
bun test --coverage

# Run formatter on the staged files
echo "âœ¨ Formatting files..."
bun x ultracite fix
FORMAT_EXIT_CODE=$?

# Restore working directory state
if [ $STASHED -eq 0 ]; then
  # Re-stage the formatted files
  if [ -n "$STAGED_FILES" ]; then
    echo "$STAGED_FILES" | while IFS= read -r file; do
      if [ -f "$file" ]; then
        git add "$file"
      fi
    done
  fi

  # Restore unstaged changes
  git stash pop --quiet || true

  # Restore partial staging if files were partially staged
  if [ -n "$PARTIALLY_STAGED" ]; then
    for file in $PARTIALLY_STAGED; do
      if [ -f "$file" ] && echo "$STAGED_FILES" | grep -q "^$file$"; then
        # File was partially staged - need to unstage the unstaged parts
        git restore --staged "$file" 2>/dev/null || true
        git add -p "$file" < /dev/null 2>/dev/null || git add "$file"
      fi
    done
  fi
else
  # No stash was created, just re-add the formatted files
  if [ -n "$STAGED_FILES" ]; then
    echo "$STAGED_FILES" | while IFS= read -r file; do
      if [ -f "$file" ]; then
        git add "$file"
      fi
    done
  fi
fi

# Check if staged files actually changed
NEW_STAGED_HASH=$(git diff --cached | sha256sum | cut -d' ' -f1)
if [ "$STAGED_HASH" != "$NEW_STAGED_HASH" ]; then
  echo "âœ¨ Files formatted by Ultracite"
fi

echo "âœ… Pre-commit checks passed"
exit $FORMAT_EXIT_CODE
